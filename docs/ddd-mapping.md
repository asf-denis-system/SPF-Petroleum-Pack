---
type: doc
status: draft
created: 2026-02-10
updated: 2026-02-10
---

# DDD и FPF/SPF/Pack: полный маппинг

> **Цель:** Формализовать знание о том, как методология FPF→SPF→Pack→Downstream соотносится с Domain-Driven Design. Что DDD делает, что отвергает, какие плюсы и минусы у обоих подходов, и как идеи DDD живут в нашей архитектуре.
>
> **Краткая версия:** [fpf-spf-pack.md § 14.1](fpf-spf-pack.md)
> **Downstream:** пост для клуба — [Knowledge-Index-Tseren/posts/2026-02-10-ddd-vs-fpf-spf-pack.md](https://github.com/TserenTserenov/Knowledge-Index-Tseren/blob/main/posts/2026-02-10-ddd-vs-fpf-spf-pack.md)

---

## 1. Что такое DDD

**Domain-Driven Design** (предметно-ориентированное проектирование) — подход к разработке ПО, предложенный Эриком Эвансом (2003). Ключевая идея:

> *«Сердце ПО — в его способности решать проблемы предметной области для пользователя.»*

DDD утверждает: сложность софта лежит в домене, а не в технологии. Проектирование должно управляться пониманием домена: глубокое погружение в бизнес, постоянное сотрудничество экспертов и разработчиков, единый язык (Ubiquitous Language) во всех артефактах.

### 1.1. Два уровня DDD

| Уровень | Что делает | Масштаб |
|---------|-----------|---------|
| **Strategic DDD** | Как декомпозировать большой домен и как части связаны | Организация, система систем |
| **Tactical DDD** | Как реализовать доменную модель внутри одного контекста | Один сервис, один модуль |

### 1.2. Ключевые книги

| Книга | Автор | Год | Фокус |
|-------|-------|-----|-------|
| *Domain-Driven Design: Tackling Complexity in the Heart of Software* | Eric Evans | 2003 | Основополагающая «синяя книга» — все паттерны |
| *DDD Reference* | Eric Evans | 2015 | Сжатый справочник всех паттернов (бесплатный PDF) |
| *Implementing Domain-Driven Design* | Vaughn Vernon | 2013 | «Красная книга» — практическое руководство |
| *Domain-Driven Design Distilled* | Vaughn Vernon | 2016 | Краткое введение (170 стр.) |

---

## 2. Рабочие продукты DDD

DDD производит артефакты **двух видов**: описания (не-код) и код.

### 2.1. Описательные артефакты (не-код)

Эти артефакты существуют **до** и **независимо** от кода. Команда может провести Event Storming и построить Context Map, не написав ни строчки.

| # | Рабочий продукт | Что это физически | Кто делает |
|---|-----------------|-------------------|-----------|
| 1 | **Ubiquitous Language Glossary** | Документ/вики: таблица терминов с определениями | Эксперты + разработчики вместе |
| 2 | **Bounded Context Definitions** | Документ: граница, внутри — термины и правила | Архитектор + эксперты |
| 3 | **Context Map** | Диаграмма: все контексты и связи между ними | Архитектор |
| 4 | **Subdomain Classification** | Таблица: Core / Supporting / Generic | Стратег/архитектор |
| 5 | **Domain Vision Statement** | 1 страница: зачем этот домен, в чём ценность | Продакт + эксперт |
| 6 | **Event Storming Board** | Стикеры/Miro: события → команды → агрегаты → политики | Вся команда |

### 2.2. Кодовые артефакты

| # | Рабочий продукт | Что это | Пример |
|---|-----------------|---------|--------|
| 7 | **Entity** | Класс с уникальным ID и жизненным циклом | `class Order(id: OrderId)` |
| 8 | **Value Object** | Неизменяемый класс без ID, определяется значениями | `class Money(amount, currency)` |
| 9 | **Aggregate** | Корневой Entity + вложенные объекты с общими инвариантами | `Order` → `OrderLine[]`, доступ только через `Order` |
| 10 | **Domain Event** | Объект-уведомление: что-то произошло в домене | `class OrderPlaced(orderId, timestamp)` |
| 11 | **Domain Service** | Операция без состояния, не принадлежит одной сущности | `PricingService.calculate(order, discounts)` |
| 12 | **Repository** | Абстракция хранения/извлечения агрегатов | `OrderRepository { find(id), save(order) }` |
| 13 | **Factory** | Инкапсуляция сложного создания объектов | `OrderFactory.createFromCart(cart)` |
| 14 | **Layered Architecture** | Структура: UI → Application → Domain → Infrastructure | 4 слоя, зависимости только вниз |

### 2.3. Важное уточнение: описания в DDD служат коду

В DDD описательные артефакты — **промежуточные**:
- Glossary нужен, чтобы классы назывались правильно
- Context Map — чтобы микросервисы были нарезаны правильно
- Event Storming — чтобы найти агрегаты для кода

Конечная цель всех описаний в DDD — **код**. Это осознанное решение Эванса (см. §3).

---

## 3. Позиция Эванса: «Модель — это код»

### 3.1. Что Эванс отвергает

Эванс явно выступает против «модели на полке» — документа, который пишется аналитиками, передаётся разработчикам и дальше живёт отдельно от кода.

> *«The model is not the diagram. The model is not the document. The model IS the code.»*

### 3.2. Аргументы Эванса

| Аргумент | Суть |
|----------|------|
| **Модель = код** | Доменная модель материализуется непосредственно в коде доменного слоя. Агрегаты, сущности, Value Objects, доменные события — всё это и есть «формализация» |
| **UL — устный, не документный** | Единый язык поддерживается через постоянное общение, парное программирование, обсуждения. Глоссарий — вспомогательный, а не центральный артефакт |
| **Context Map — неформальна** | Может быть рисунком на доске, диаграммой в вики. Строгого формата DDD не предписывает |
| **Документ неизбежно устаревает** | Любой документ, оторванный от кода, рано или поздно расходится с реальностью. Лучше сделать код настолько выразительным, чтобы он сам был читаемой моделью |

### 3.3. Логика этой позиции

Эванс решает конкретную проблему: в 2003 году типичный проект выглядел так:
1. Аналитик пишет документ с требованиями
2. Архитектор рисует диаграммы
3. Разработчик пишет код, который не соответствует ни тому, ни другому
4. Документы устаревают на следующий день

DDD говорит: **выбросьте промежуточные документы, сделайте код моделью**.

---

## 4. Плюсы и минусы подхода DDD

### 4.1. Плюсы

| Плюс | Почему это ценно |
|------|-----------------|
| **Код = модель → нет рассинхронизации** | Единственный source-of-truth (код) не может устареть сам относительно себя |
| **Глубокое понимание домена** | Knowledge crunching заставляет разработчиков разбираться в бизнесе |
| **Выразительный код** | Intention-revealing interfaces, ubiquitous language в именах классов — код читается как описание домена |
| **Bounded Context** | Чёткие границы предотвращают «Big Ball of Mud» — модульность на архитектурном уровне |
| **Богатая таксономия интеграции** | 9 паттернов Context Map (Partnership, ACL, Conformist...) — точные инструменты для описания связей |

### 4.2. Минусы

| Минус | Последствия |
|-------|-----------|
| **Знание заперто в коде** | Бизнес-эксперт, который не читает код, не может валидировать модель самостоятельно. UL работает только пока команда регулярно общается |
| **Нет передачи знания без людей** | Уходит ключевой разработчик/эксперт — знание о *почему* модель устроена именно так теряется. Код показывает *что*, но не *почему* |
| **Нет формальной верификации** | Нельзя проверить, что код соответствует доменным правилам, потому что эти правила нигде не зафиксированы отдельно от кода в структурированной форме |
| **Масштабирование через людей, а не артефакты** | DDD хорошо работает в одной команде с живым общением. Когда команд становится много, устный UL перестаёт масштабироваться |
| **Смешение домена и реализации** | Код — реализация на конкретном языке, в конкретном фреймворке, с техническими компромиссами. Доменное знание неизбежно смешивается с решениями реализации |
| **Нет мета-уровня** | Нет способа формализовать правила создания моделей. Каждая команда изобретает свой подход |

### 4.3. Попытки компенсировать минусы

Были попытки дополнить DDD формальными артефактами, но ни одна не стала стандартом:

| Попытка | Что делает | Почему не решает проблему |
|---------|-----------|-------------------------|
| **Event Storming** (Brandolini) | Визуальная карта событий на стикерах | Неформальна, быстро устаревает |
| **Domain Story Telling** | Визуальные нарративы | Нет строгого формата |
| **BDD (Given-When-Then)** | Исполняемые спецификации | Привязаны к тестовому фреймворку |
| **ADR** (Architecture Decision Records) | Фиксируют решения | Фиксируют решения, а не модель |

---

## 5. Плюсы и минусы подхода FPF/SPF/Pack

### 5.1. Плюсы

| Плюс | Почему это ценно |
|------|-----------------|
| **Знание — самостоятельный артефакт** | Pack существует и имеет ценность без кода. Доменный эксперт может читать, валидировать и улучшать Pack |
| **Передача знания через артефакт** | Pack можно передать другой команде, другому проекту, AI-агенту — без устного объяснения |
| **Формальная верификация** | Distinctions с тестами, failure modes, trust metrics — структурированные способы проверки корректности |
| **Масштабирование через Pack** | Новая команда читает Pack и получает формализованное знание домена. Не нужен ментор-человек |
| **Мета-уровни** | FPF → SPF обеспечивают переносимость паттернов между доменами. Правила создания Pack'ов одинаковы для любого домена |
| **Явное отслеживание эволюции** | SoTA + revision criteria показывают когда знание устарело. В DDD модель рефакторится по необходимости, без системы |
| **Downstream contract** | Явный интерфейс между знанием и применением. Код, курсы, агенты — всё использует один Pack |

### 5.2. Минусы

| Минус | Последствия |
|-------|-----------|
| **Два source-of-truth** | Pack (текст) и Code (downstream) могут рассинхронизироваться — та самая проблема, которую Эванс решал. Требуется явный процесс синхронизации (см. §6) |
| **Overhead на формализацию** | Создание Pack'а с ID, frontmatter, distinctions, failure modes — значительные затраты. Для маленькой команды может быть избыточно |
| **Нет runtime-паттернов** | Aggregate, Domain Event, Repository — паттерны организации кода, которых нет в Pack. При переходе к коду нужно дополнительно применять DDD |
| **Риск «модели на полке»** | Если процесс синхронизации Pack→Code не работает, Pack становится тем самым устаревшим документом, против которого выступал Эванс |
| **Молодая методология** | Нет широкого community, нет проверки на масштабе, мало tooling |

---

## 6. Проблема двух источников истины: Pack vs Code

### 6.1. Постановка проблемы

Эванс прав: документ, оторванный от кода, устаревает. Мы принимаем эту проблему, но решаем её иначе.

В DDD решение: **убрать документ, оставить код**.
В FPF/SPP/Pack решение: **сохранить оба, ввести процесс синхронизации**.

### 6.2. Когда Pack и Code расходятся

Расхождение Pack и Code — нормальная ситуация. Вопрос: **что обновить?**

| Ситуация | Что обновить | Почему |
|----------|-------------|--------|
| Обнаружено новое доменное знание при разработке кода | **Pack** (затем Code подтягивается) | Pack — source-of-truth. Знание формализуется в Pack, код следует |
| Технический компромисс в коде вынуждает отклониться от модели | **Code** (с ADR-записью, почему) | Реализация может требовать компромиссов, но Pack остаётся «идеальной» моделью |
| Бизнес-эксперт нашёл ошибку в модели | **Pack** (затем Code подтягивается) | Эксперт валидирует Pack напрямую |
| Код рефакторится и открывает лучшую структуру | **Оба**: Pack уточняется, Code закрепляет | Рефакторинг кода — форма knowledge crunching |
| AI-агент работает с устаревшим Pack | **Pack** (обновить до текущего понимания) | Агент должен работать с актуальным знанием |

### 6.3. Правило синхронизации

> **При расхождении Pack и Code — не обновляй автоматически одно из двух. Определи, где истина, и обнови то, что ошибается.**

Это отличается от DDD (где код всегда прав) и от традиционного waterfall (где документ всегда прав). Наш подход: **истина определяется анализом**, а не конвенцией.

### 6.4. Механизмы предотвращения рассинхронизации

| Механизм | Как работает | Статус |
|----------|-------------|--------|
| **Capture-to-Pack** (протокол Work) | При разработке кода обнаруженное знание фиксируется в Pack | Реализован |
| **Downstream contract** (SPF spec) | Явный интерфейс Pack→Code с правилами трассировки | Реализован |
| **SoTA + revision criteria** | Каждая сущность Pack имеет критерий пересмотра | Реализован |
| **Process lint** | Автоматическая проверка Pack на соответствие SPF | Частично |
| **Code lint → Pack** | Проверка, что Code ссылается на Pack-сущности | Не реализован (потенциал) |

---

## 7. Как идеи DDD живут в FPF/SPF/Pack

### 7.1. Идеи, которые мы взяли и обобщили

| Идея DDD | Как живёт у нас | Что мы добавили |
|----------|----------------|----------------|
| **Bounded Context** | U.BoundedContext (FPF A.1.1) → Pack (SPF) | Обобщение на любой домен (не только код). 4 обязательных компонента: Glossary, Invariants, Roles, Bridges |
| **Ubiquitous Language** | Glossary + Distinctions (SPF 01A, 01B) | Тесты на нарушение, failure modes, формальные ID |
| **Knowledge Crunching** | 11-step process (SPF process/) + Capture-to-Pack | Формализованный процесс вместо неформальных воркшопов |
| **Model-Driven Design** | Pack-driven Downstream | Код генерируется/пишется на основе Pack, а не наоборот |
| **Явные границы** | Pack Manifest (scope: in/out) + Bridges | upstream/downstream зависимости, loss/fit-аннотации |

### 7.2. Идеи, которые мы НЕ взяли (и почему)

| Идея DDD | Почему не взяли | Последствие |
|----------|----------------|------------|
| **«Модель = код»** | Мы считаем знание самостоятельным артефактом, не привязанным к реализации | Требуется процесс синхронизации (§6) |
| **Aggregate** (runtime-граница) | Pack — knowledge-time, нет runtime | Нет паттерна «группа сущностей, обновляемых вместе». Потенциально полезно ввести **Knowledge Aggregate** |
| **Domain Events** (runtime-уведомления) | Pack не исполняется | Нет способа описать «что произошло». Но это и не нужно в knowledge-time |
| **Value Objects** (неизменяемые, без ID) | Все сущности Pack имеют ID | Некоторые элементы (метрики, характеристики) могли бы быть value objects, но мы не различаем |
| **Repository** (хранение агрегатов) | Это паттерн реализации | Живёт в downstream/instrument (код) |

### 7.3. Идеи, которые мы можем взять

| Что | Зачем | Куда положить | Приоритет |
|-----|-------|-------------|-----------|
| **Context Map Integration Patterns** (9 паттернов) | Расширить типы Bridges: Partnership, ACL, Conformist, Open Host, Shared Kernel, etc. | FPF Bridges или SPF spec | Высокий |
| **Core/Supporting/Generic** | Приоритизация инвестиций в формализацию Pack'ов | Pack Manifest: поле `subdomain_type` | Средний |
| **Knowledge Aggregate** | Группы сущностей Pack, которые ДОЛЖНЫ обновляться вместе | SPF process | Средний |
| **Knowledge Storming** (адаптация Event Storming) | Метод обнаружения сущностей, различений и failure modes | SPF process (steps 3-4) | Низкий |

---

## 8. Сводная таблица: DDD vs FPF/SPF/Pack

### 8.1. По возможностям

| Возможность | DDD | FPF/SPF/Pack |
|-------------|-----|-------------|
| Формализация знания домена | Через код (runtime) | Через структурированный текст (knowledge-time) |
| Bounded Context | Да | Да (обобщённый) |
| Единый язык | UL (устный + в коде) | Glossary + Distinctions (формальный, с тестами) |
| Паттерны интеграции контекстов | 9 паттернов (ACL, Partnership...) | Bridges (менее развитые) |
| Мета-уровень | Нет | FPF → SPF (2 мета-уровня) |
| Runtime-паттерны | Aggregate, Event, Service, Repository | Нет (в downstream) |
| Failure modes | Нет | Да (SPF 05, первоклассные граждане) |
| Trust/readiness метрики | Нет | Да (F, G, R) |
| SoTA отслеживание | Нет | Да (статус + revision criteria) |
| Downstream contract | Нет | Да (явный интерфейс знание→применение) |
| Классификация доменов | Core/Supporting/Generic | Нет (можно взять) |
| Tooling и community | Зрелый (20+ лет) | Молодой |

### 8.2. По source-of-truth

| Аспект | DDD | FPF/SPF/Pack |
|--------|-----|-------------|
| **Source-of-truth** | Код | Pack (текст) |
| **Если текст ≠ код** | Обнови текст (код прав) | Определи, где истина, и обнови ошибающийся |
| **Кто валидирует** | Разработчик (читает код) | Эксперт (читает Pack) + разработчик (читает код) |
| **Масштабирование** | Через людей (общение) | Через артефакт (Pack) |
| **Риск** | Знание заперто в коде | Рассинхронизация Pack и Code |

### 8.3. По рабочим продуктам

| DDD-артефакт | Аналог в FPF/SPF/Pack | Совпадение |
|-------------|----------------------|-----------|
| Ubiquitous Language Glossary | Glossary + Distinctions | Высокое (наши строже) |
| Bounded Context Definition | Pack = Bounded Context | Высокое (наши обобщённее) |
| Context Map | Bridges + Pack Manifest | Среднее (DDD богаче) |
| Domain Vision Statement | Pack Manifest (scope) | Среднее |
| Subdomain Classification | — | Нет (можно взять) |
| Entity | Domain Entity (DP.XXX.NNN) | Среднее |
| Value Object | — | Нет аналога |
| Aggregate | — | Нет (→ Knowledge Aggregate) |
| Domain Event | — | Нет (runtime vs knowledge-time) |
| Domain Service | Method (SPF 03) | Среднее |
| Repository | Downstream/instrument | Низкое |
| Layered Architecture | 4-уровневая иерархия | Аналогия (разные слои) |

---

## 9. Позиционирование: что мы такое относительно DDD

### 9.1. Формулировка

> **FPF/SPF/Pack — это обобщение ключевых паттернов DDD (Bounded Context, Ubiquitous Language, явные границы) за пределы кода, на формализацию доменного знания как самостоятельного артефакта.**
>
> DDD формализует домен **через код**. Мы формализуем домен **до кода**, в структурированном тексте (Pack), а код является downstream-продуктом Pack'а.
>
> При этом мы добавляем то, чего нет в DDD: мета-уровни (FPF/SPF), failure modes, trust metrics, SoTA, downstream contracts.
>
> DDD и FPF/SPF/Pack **не конкурируют — они последовательны**:
>
> ```
> Домен (реальность)
>     ↓  FPF/SPF/Pack: формализация знания
> Pack (source-of-truth)
>     ↓  DDD: проектирование кода на основе знания
> Код (downstream/instrument)
> ```

### 9.2. Можно ли говорить «мы делаем DDD»?

**Нет** — это было бы неточно. DDD — про код. Мы — про знание до кода.

**Да** — можно говорить: «мы используем паттерны DDD (Bounded Context, UL), обобщённые на knowledge management».

**Точнее всего:** «Наш подход включает и расширяет стратегические паттерны DDD, но добавляет самостоятельный артефакт доменного знания (Pack), которого DDD не создаёт».

---

## 10. Суть проблемы, которую мы решаем

DDD по факту предлагает: «пусть код будет моделью». Но код — это реализация на конкретном языке, в конкретном фреймворке, с техническими компромиссами. Он неизбежно смешивает доменное знание с решениями реализации.

Полноценный артефакт доменного знания — независимый от реализации, верифицируемый, читаемый и для бизнеса, и для разработчиков, и для AI-агентов — DDD не создаёт. Это осознанное решение Эванса, а не упущение. Но у него есть последствия:

- **Знание заперто в коде** — бизнес-эксперт не может валидировать
- **Нет передачи без людей** — уходит разработчик, уходит знание «почему»
- **Нет формальной верификации** — правила домена нигде не зафиксированы отдельно
- **Масштабирование через людей** — устный UL не масштабируется на много команд

Pack решает эти проблемы, создавая самостоятельный артефакт доменного знания. Ценой — необходимости поддерживать синхронизацию Pack и Code (§6).

---

## Источники

- Evans, Eric. *Domain-Driven Design: Tackling Complexity in the Heart of Software.* 2003.
- Evans, Eric. *Domain-Driven Design Reference.* 2015. (CC-licensed)
- Vernon, Vaughn. *Implementing Domain-Driven Design.* 2013.
- Vernon, Vaughn. *Domain-Driven Design Distilled.* 2016.
- Fowler, Martin. [BoundedContext](https://martinfowler.com/bliki/BoundedContext.html), [DomainDrivenDesign](https://martinfowler.com/bliki/DomainDrivenDesign.html).
- FPF-Spec.md, A.1.1 (U.BoundedContext): *«FPF generalizes the proven DDD idea of a Bounded Context from software into a universal modeling primitive.»*
- SPF/docs/fpf-spf-pack.md, §14.1.
